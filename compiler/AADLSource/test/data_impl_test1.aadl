package DATA_Impl_Tests

public
with Base_Types;

-- Processor
processor CPU
end CPU;

processor implementation CPU.Impl
properties
Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
Priority_Range => 0 .. 99;
end CPU.Impl;

data Shared_Int
end Shared_Int;

data implementation Shared_Int.Impl
end Shared_Int.Impl;

-- 共享数据访问用的子程序（用于产生多个 Subprogram 子组件）
subprogram Writer_Spg
features
D : in out parameter Base_Types::Integer;
end Writer_Spg;

subprogram Reader_Spg
features
D : in out parameter Base_Types::Integer;
end Reader_Spg;

-- 情形 1：多个 subprogram + 恰好 1 个 data（classifier 为 Implementation）
-- 覆盖：
-- - convert_data_implementation 中 subprogram_count > 1
-- - data_subcomponents.len() == 1
-- - match Implementation(...) 分支
data Shared_Impl_Only
end Shared_Impl_Only;

data implementation Shared_Impl_Only.Impl
subcomponents
Writer : subprogram Writer_Spg;
Reader : subprogram Reader_Spg;
Val : data Shared_Int.Impl; -- 指向 data implementation
end Shared_Impl_Only.Impl;

-- 情形 2：多个 subprogram + 恰好 1 个 data（classifier 为 Type）
-- 覆盖：
-- - subprogram_count > 1
-- - data_subcomponents.len() == 1
-- - match 中走到默认分支，生成 "UnknownType"
data Shared_Type_Only
end Shared_Type_Only;

data implementation Shared_Type_Only.Impl
subcomponents
Writer : subprogram Writer_Spg;
Reader : subprogram Reader_Spg;
Val : data Base_Types::Integer; -- 只引用类型，触发 UnknownType 分支
end Shared_Type_Only.Impl;

-- 情形 3：多个 subprogram + 多个 data 子组件
-- 覆盖：
-- - data_subcomponents.len() > 1 报错分支
data Shared_Multi_Data
end Shared_Multi_Data;

data implementation Shared_Multi_Data.Impl
subcomponents
Writer : subprogram Writer_Spg;
Reader : subprogram Reader_Spg;
V1 : data Base_Types::Integer;
V2 : data Base_Types::Boolean;
end Shared_Multi_Data.Impl;

-- 情形 4：复杂数据类型 Struct
-- 期望被上游逻辑标记到 data_comp_type[Record_Data.Impl] = "struct"
-- 字段引用 Base_Types::*，使 determine_struct_impl 中
-- UniqueComponentClassifierReference::Type(type_ref) 分支被执行
data Record_Data
end Record_Data;

data implementation Record_Data.Impl
subcomponents
F1 : data Base_Types::Integer;
F2 : data Base_Types::Boolean;
properties
Data_Representation => Struct;
end Record_Data.Impl;

-- 情形 5：复杂数据类型 Union
-- 期望被标记为 data_comp_type[Union_Data.Impl] = "union"
-- 同样让 determine_union_impl 中的 Type 分支被覆盖
data Union_Data
end Union_Data;

data implementation Union_Data.Impl
subcomponents
As_Int : data Base_Types::Integer;
As_Bool : data Base_Types::Boolean;
properties
Data_Representation => Union;
end Union_Data.Impl;

process Data_Test_Proc
end Data_Test_Proc;

process implementation Data_Test_Proc.Impl
subcomponents
Shared1 : data Shared_Impl_Only.Impl;
Shared2 : data Shared_Type_Only.Impl;
Shared3 : data Shared_Multi_Data.Impl;

RecInst : data Record_Data.Impl;
UnionInst : data Union_Data.Impl;
end Data_Test_Proc.Impl;

system Data_Test_System
end Data_Test_System;

system implementation Data_Test_System.Impl
subcomponents
Proc : process Data_Test_Proc.Impl;
CPU : processor CPU.Impl;

properties
Actual_processor_binding => reference (CPU) applies to Proc;
end Data_Test_System.Impl;

end DATA_Impl_Tests;