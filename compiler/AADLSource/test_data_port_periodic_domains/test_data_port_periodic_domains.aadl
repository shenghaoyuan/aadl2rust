-- 系统功能：演示跨调度域的数据端口通信机制
--   - source_thread线程：周期性线程（周期1000ms），产生64位整数数据并写入数据端口
--   - destination_thread线程：周期性线程（周期1000ms），从数据端口读取64位整数数据
-- 两个线程分别位于不同的进程中，通过系统级数据端口连接进行跨进程通信

-- 系统特点：
-- 1. 专门测试跨调度域（Domain）的数据端口通信，适用于分区调度系统
-- 2. 两个周期性线程具有相同的执行周期（1000ms）和计算执行时间（10ms）
-- 3. 通过子程序调用将AADL端口与C函数参数直接映射，展示C代码集成的完整流程
-- 4. 处理器配置了帧周期（1000ms）和时钟周期（2ms），为域调度提供精确时间基准
-- 5. 注释中包含调度域配置示例（Domain => 2/3），可用于分区隔离调度
-- 6. 明确的处理器绑定配置，确保两个进程在同一处理器上运行

----------------------------------------------------------------------
-- Copyright 2020 DARPA CASE
--
-- Micro example AADL to show single AADL dataport communications for
-- a periodic process running under the seL4 domain scheduler
----------------------------------------------------------------------
package test_data_port_periodic_domains
public
	with Base_Types;
	-- with HAMR;
	-- with CASE_Scheduling;

    ----------------------------------------------------------------------
    -- no inputs, one output, periodically places a value on the dataport
    ----------------------------------------------------------------------
    -- thread specifies unit of temporal execution; depending on scheduling
    -- model this can provide temporal isolation.

	subprogram C_A
	features
		out_param : out parameter Base_Types::Integer_64;
	properties
		source_language => (C);
		source_name => "test_data_port_periodic_domains_source_component_time_triggered";
		source_text     => ("source.c");
	end C_A;

	subprogram C_B
		features
			in_param : in parameter Base_Types::Integer_64;
		properties
			source_language => (C);
			source_name => "test_data_port_periodic_domains_destination_component_time_triggered";
			source_text     => ("source.c");
	end C_B;

	thread source_thread
		features
			write_port: out data port Base_Types::Integer_64;
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 10ms .. 10ms;
			-- Source_Text => ("behavior_code/components/source/src/source.c");
			-- Initialize_Entrypoint_Source_Text => "test_data_port_periodic_domains_source_component_init";
			-- Compute_Entrypoint_Source_Text => "test_data_port_periodic_domains_source_component_time_triggered";
	end source_thread;

	thread implementation source_thread.impl
	calls 
	Mycalls: {
		A_Spg : subprogram C_A;
	};
	connections
		cnx_a : parameter A_Spg.out_param -> write_port;
	end source_thread.impl;

    -- process specifies boundary of spatial isolation
	process source_process
		features
			write_port: out data port Base_Types::Integer_64;
		-- properties
		-- 	CASE_Scheduling::Domain => 2; -- pacer 1, source 2, destination 3
	end source_process;

	process implementation source_process.impl
		subcomponents
			source_thread_component: thread source_thread.impl;
		connections
			write_connection: port source_thread_component.write_port -> write_port;
	end source_process.impl;

    ----------------------------------------------------------------------
    -- one input, no outputs, periodically reads a value from the dataport
    ----------------------------------------------------------------------
    -- thread specifies unit of temporal execution; depending on scheduling
    -- model this can provide temporal isolation.
	thread destination_thread
		features
			read_port: in data port Base_Types::Integer_64;
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 10ms .. 10ms;
			-- Source_Text => ("behavior_code/components/destination/src/destination.c");
			-- Initialize_Entrypoint_Source_Text => "test_data_port_periodic_domains_destination_component_init";
			-- Compute_Entrypoint_Source_Text => "test_data_port_periodic_domains_destination_component_time_triggered";
	end destination_thread;

	thread implementation destination_thread.impl
	calls 
	Mycalls: {
		B_Spg : subprogram C_B;
	};
	connections
		cnx_b : parameter read_port -> B_Spg.in_param;
	end destination_thread.impl;

    -- process specifies boundary of spatial isolation
	process destination_process
		features
			read_port: in data port Base_Types::Integer_64;
		-- properties
		-- 	CASE_Scheduling::Domain => 3; -- pacer 1, source 2, destination 3
	end destination_process;

	process implementation destination_process.impl
		subcomponents
			destination_thread_component: thread destination_thread.impl;
		connections
			read_connection: port read_port -> destination_thread_component.read_port;
	end destination_process.impl;

    ----------------------------------------------------------------------
	processor proc
	end proc;

	processor implementation proc.impl
		properties
			Frame_Period => 1000ms;
            Clock_Period => 2ms;
            -- CASE_Scheduling::Max_Domain => 3;
			-- CASE_Scheduling::Schedule_Source_Text => "behavior_code/kernel/domain_schedule.c";
	end proc.impl;

    ----------------------------------------------------------------------
	system top
	end top;

	system implementation top.impl
		subcomponents
			proc: processor proc.impl;
			source_process_component: process source_process.impl;
			destination_process_component: process destination_process.impl;
		connections
			data_interconnect: port source_process_component.write_port -> destination_process_component.read_port;
		properties
			Actual_Processor_Binding => reference (proc) applies to source_process_component;
			Actual_Processor_Binding => reference (proc) applies to destination_process_component;
			-- HAMR::Platform => (seL4_TB, seL4_Only);
		--annex resolute {**
		--	check CASE_Tools
		--**};
	end top.impl;
	
end test_data_port_periodic_domains;
