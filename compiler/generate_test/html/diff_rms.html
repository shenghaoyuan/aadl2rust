<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<title>Diff for RMS</title>
<style>
body {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  background: #1e1e1e;
  color: #d4d4d4;
}
pre {
  white-space: pre-wrap;
}
.line-add    { background-color: #003800; color: #c8ffc8; }
.line-remove { background-color: #3f0001; color: #ffcccc; }
.line-header { color: #4fc1ff; font-weight: bold; }
</style>
</head>
<body>
<h2>Diff for RMS</h2>
<pre>
<span class="line-remove">--- original</span>
<span class="line-add">+++ modified</span>
<span class="line-header">@@ -1,21 +1,21 @@</span>
<span class="line-remove">-// 自动生成的 Rust 代码 - 来自 AADL 模型</span>
<span class="line-remove">-// 生成时间: 2025-12-08 22:37:53</span>
<span class="line-add">+// Auto-generated from AADL package: rmsaadl</span>
<span class="line-add">+// 生成时间: 2025-12-21 19:44:32</span>

 #![allow(unused_imports)]
<span class="line-remove">-use crate::common_traits::*;</span>
 use crossbeam_channel::{Receiver, Sender};
<span class="line-add">+use std::sync::{Arc,Mutex};</span>
<span class="line-add">+use std::thread;</span>
<span class="line-add">+use std::time::{Duration, Instant};</span>
 use lazy_static::lazy_static;
<span class="line-add">+use std::collections::HashMap;</span>
<span class="line-add">+use crate::common_traits::*;</span>
<span class="line-add">+use tokio::sync::broadcast::{self,Sender as BcSender, Receiver as BcReceiver};</span>
 use libc::{self, syscall, SYS_gettid};
<span class="line-add">+use rand::{Rng};</span>
 use libc::{
<span class="line-remove">-    cpu_set_t, pthread_self, pthread_setschedparam, sched_param, sched_setaffinity, CPU_SET,</span>
<span class="line-remove">-    CPU_ZERO, SCHED_FIFO,</span>
<span class="line-add">+    pthread_self, sched_param, pthread_setschedparam, SCHED_FIFO,</span>
<span class="line-add">+    cpu_set_t, CPU_SET, CPU_ZERO, sched_setaffinity,</span>
 };
<span class="line-remove">-use rand::Rng;</span>
<span class="line-remove">-use std::collections::HashMap;</span>
<span class="line-remove">-use std::sync::{Arc, Mutex};</span>
<span class="line-remove">-use std::thread;</span>
<span class="line-remove">-use std::time::{Duration, Instant};</span>
<span class="line-remove">-use tokio::sync::broadcast::{self, Receiver as BcReceiver, Sender as BcSender};</span>
 include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/aadl_c_bindings.rs&quot;));

 // ---------------- cpu ----------------
<span class="line-header">@@ -32,14 +32,14 @@</span>
     // Auto-generated from AADL subprogram: Hello_Spg_1
     // C binding to: user_hello_spg_1
     // source_files: hello.c
<span class="line-remove">-    use super::user_hello_spg_1;</span>
<span class="line-add">+    use super::{user_hello_spg_1};</span>
     // Direct execution wrapper for C function user_hello_spg_1
     // This component has no communication ports
     pub fn execute() -&gt; () {
<span class="line-remove">-        unsafe {</span>
<span class="line-remove">-            user_hello_spg_1();</span>
<span class="line-remove">-        };</span>
<span class="line-add">+        unsafe { user_hello_spg_1();</span>
<span class="line-add">+         };</span>
     }
<span class="line-add">+    </span>
 }

 pub mod hello_spg_2 {
<span class="line-header">@@ -46,23 +46,23 @@</span>
     // Auto-generated from AADL subprogram: Hello_Spg_2
     // C binding to: user_hello_spg_2
     // source_files: hello.c
<span class="line-remove">-    use super::user_hello_spg_2;</span>
<span class="line-add">+    use super::{user_hello_spg_2};</span>
     // Direct execution wrapper for C function user_hello_spg_2
     // This component has no communication ports
     pub fn execute() -&gt; () {
<span class="line-remove">-        unsafe {</span>
<span class="line-remove">-            user_hello_spg_2();</span>
<span class="line-remove">-        };</span>
<span class="line-add">+        unsafe { user_hello_spg_2();</span>
<span class="line-add">+         };</span>
     }
<span class="line-add">+    </span>
 }

 // AADL Thread: task
 #[derive(Debug)]
 pub struct taskThread {
<span class="line-remove">-    pub cpu_id: isize,             // 结构体新增 CPU ID</span>
<span class="line-remove">-    pub dispatch_protocol: String, // AADL属性(impl): Dispatch_Protocol</span>
<span class="line-remove">-    pub period: u64,               // AADL属性(impl): Period</span>
<span class="line-remove">-    pub deadline: u64,             // AADL属性(impl): Deadline</span>
<span class="line-add">+    pub cpu_id: isize,// 结构体新增 CPU ID</span>
<span class="line-add">+    pub dispatch_protocol: String,// AADL属性(impl): Dispatch_Protocol</span>
<span class="line-add">+    pub period: u64,// AADL属性(impl): Period</span>
<span class="line-add">+    pub deadline: u64,// AADL属性(impl): Deadline</span>
 }

 impl Thread for taskThread {
<span class="line-header">@@ -69,33 +69,23 @@</span>
     // 创建组件并初始化AADL属性
     fn new(cpu_id: isize) -&gt; Self {
         return Self {
<span class="line-remove">-            deadline: 1000,</span>
<span class="line-remove">-            dispatch_protocol: &quot;Periodic&quot;.to_string(),</span>
<span class="line-remove">-            period: 1000,</span>
<span class="line-add">+            deadline: 1000, </span>
<span class="line-add">+            priority: 1, </span>
<span class="line-add">+            period: 1000, </span>
<span class="line-add">+            dispatch_protocol: &quot;Periodic&quot;.to_string(), </span>
             cpu_id: cpu_id, // CPU ID
         };
     }
<span class="line-remove">-</span>
<span class="line-add">+    </span>
     // Thread execution entry point
     // Period: Some(1000) ms
     fn run(mut self) -&gt; () {
         unsafe {
             let prio = period_to_priority(self.period as f64);
<span class="line-remove">-            let mut param: sched_param = sched_param {</span>
<span class="line-remove">-                sched_priority: prio,</span>
<span class="line-remove">-            };</span>
<span class="line-remove">-            let ret = pthread_setschedparam(</span>
<span class="line-remove">-                pthread_self(),</span>
<span class="line-remove">-                *CPU_ID_TO_SCHED_POLICY</span>
<span class="line-remove">-                    .get(&amp;self.cpu_id)</span>
<span class="line-remove">-                    .unwrap_or(&amp;SCHED_FIFO),</span>
<span class="line-remove">-                &amp;mut param,</span>
<span class="line-remove">-            );</span>
<span class="line-add">+            let mut param: sched_param = sched_param { sched_priority: prio };</span>
<span class="line-add">+            let ret = pthread_setschedparam(pthread_self(), *CPU_ID_TO_SCHED_POLICY.get(&amp;self.cpu_id).unwrap_or(&amp;SCHED_FIFO), &amp;mut param);</span>
             if ret != 0 {
<span class="line-remove">-                eprintln!(</span>
<span class="line-remove">-                    &quot;taskThread: Failed to set thread priority from period: {}&quot;,</span>
<span class="line-remove">-                    ret</span>
<span class="line-remove">-                );</span>
<span class="line-add">+                eprintln!(&quot;taskThread: Failed to set thread priority from period: {}&quot;, ret);</span>
             };
         };
         if self.cpu_id &gt; -1 {
<span class="line-header">@@ -102,27 +92,31 @@</span>
             set_thread_affinity(self.cpu_id);
         };
         let period: std::time::Duration = Duration::from_millis(1000);
<span class="line-add">+        let mut next_release = Instant::now() + period;</span>
         loop {
<span class="line-remove">-            let start = Instant::now();</span>
<span class="line-add">+            let now = Instant::now();</span>
<span class="line-add">+            if now &lt; next_release {</span>
<span class="line-add">+                std::thread::sleep(next_release - now);</span>
<span class="line-add">+            };</span>
             {
                 // --- 调用序列（等价 AADL 的 Wrapper）---
<span class="line-remove">-                // p_spg();</span>
<span class="line-add">+                           // p_spg();</span>
                 // p_spg;
                 hello_spg_1::execute();
             };
<span class="line-remove">-            let elapsed = start.elapsed();</span>
<span class="line-remove">-            std::thread::sleep(period.saturating_sub(elapsed));</span>
<span class="line-remove">-        }</span>
<span class="line-add">+            next_release += period;</span>
<span class="line-add">+        };</span>
     }
<span class="line-add">+    </span>
 }

 // AADL Thread: task2
 #[derive(Debug)]
 pub struct task2Thread {
<span class="line-remove">-    pub cpu_id: isize,             // 结构体新增 CPU ID</span>
<span class="line-remove">-    pub dispatch_protocol: String, // AADL属性(impl): Dispatch_Protocol</span>
<span class="line-remove">-    pub period: u64,               // AADL属性(impl): Period</span>
<span class="line-remove">-    pub deadline: u64,             // AADL属性(impl): Deadline</span>
<span class="line-add">+    pub cpu_id: isize,// 结构体新增 CPU ID</span>
<span class="line-add">+    pub dispatch_protocol: String,// AADL属性(impl): Dispatch_Protocol</span>
<span class="line-add">+    pub period: u64,// AADL属性(impl): Period</span>
<span class="line-add">+    pub deadline: u64,// AADL属性(impl): Deadline</span>
 }

 impl Thread for task2Thread {
<span class="line-header">@@ -129,33 +123,23 @@</span>
     // 创建组件并初始化AADL属性
     fn new(cpu_id: isize) -&gt; Self {
         return Self {
<span class="line-remove">-            deadline: 500,</span>
<span class="line-remove">-            period: 500,</span>
<span class="line-remove">-            dispatch_protocol: &quot;Periodic&quot;.to_string(),</span>
<span class="line-add">+            dispatch_protocol: &quot;Periodic&quot;.to_string(), </span>
<span class="line-add">+            period: 500, </span>
<span class="line-add">+            deadline: 500, </span>
<span class="line-add">+            priority: 2, </span>
             cpu_id: cpu_id, // CPU ID
         };
     }
<span class="line-remove">-</span>
<span class="line-add">+    </span>
     // Thread execution entry point
     // Period: Some(500) ms
     fn run(mut self) -&gt; () {
         unsafe {
             let prio = period_to_priority(self.period as f64);
<span class="line-remove">-            let mut param: sched_param = sched_param {</span>
<span class="line-remove">-                sched_priority: prio,</span>
<span class="line-remove">-            };</span>
<span class="line-remove">-            let ret = pthread_setschedparam(</span>
<span class="line-remove">-                pthread_self(),</span>
<span class="line-remove">-                *CPU_ID_TO_SCHED_POLICY</span>
<span class="line-remove">-                    .get(&amp;self.cpu_id)</span>
<span class="line-remove">-                    .unwrap_or(&amp;SCHED_FIFO),</span>
<span class="line-remove">-                &amp;mut param,</span>
<span class="line-remove">-            );</span>
<span class="line-add">+            let mut param: sched_param = sched_param { sched_priority: prio };</span>
<span class="line-add">+            let ret = pthread_setschedparam(pthread_self(), *CPU_ID_TO_SCHED_POLICY.get(&amp;self.cpu_id).unwrap_or(&amp;SCHED_FIFO), &amp;mut param);</span>
             if ret != 0 {
<span class="line-remove">-                eprintln!(</span>
<span class="line-remove">-                    &quot;task2Thread: Failed to set thread priority from period: {}&quot;,</span>
<span class="line-remove">-                    ret</span>
<span class="line-remove">-                );</span>
<span class="line-add">+                eprintln!(&quot;task2Thread: Failed to set thread priority from period: {}&quot;, ret);</span>
             };
         };
         if self.cpu_id &gt; -1 {
<span class="line-header">@@ -162,79 +146,71 @@</span>
             set_thread_affinity(self.cpu_id);
         };
         let period: std::time::Duration = Duration::from_millis(500);
<span class="line-add">+        let mut next_release = Instant::now() + period;</span>
         loop {
<span class="line-remove">-            let start = Instant::now();</span>
<span class="line-add">+            let now = Instant::now();</span>
<span class="line-add">+            if now &lt; next_release {</span>
<span class="line-add">+                std::thread::sleep(next_release - now);</span>
<span class="line-add">+            };</span>
             {
                 // --- 调用序列（等价 AADL 的 Wrapper）---
<span class="line-remove">-                // p_spg();</span>
<span class="line-add">+                           // p_spg();</span>
                 // p_spg;
                 hello_spg_2::execute();
             };
<span class="line-remove">-            let elapsed = start.elapsed();</span>
<span class="line-remove">-            std::thread::sleep(period.saturating_sub(elapsed));</span>
<span class="line-remove">-        }</span>
<span class="line-add">+            next_release += period;</span>
<span class="line-add">+        };</span>
     }
<span class="line-add">+    </span>
 }

 // AADL Process: node_a
 #[derive(Debug)]
 pub struct node_aProcess {
<span class="line-remove">-    pub cpu_id: isize, // 进程 CPU ID</span>
<span class="line-remove">-    #[allow(dead_code)]</span>
<span class="line-remove">-    pub task1: taskThread, // 子组件线程（Task1 : thread Task）</span>
<span class="line-remove">-    #[allow(dead_code)]</span>
<span class="line-remove">-    pub task2: task2Thread, // 子组件线程（Task2 : thread Task2）</span>
<span class="line-add">+    pub cpu_id: isize,// 进程 CPU ID</span>
<span class="line-add">+    pub task1: taskThread,// 子组件线程（Task1 : thread Task）</span>
<span class="line-add">+    pub task2: task2Thread,// 子组件线程（Task2 : thread Task2）</span>
 }

 impl Process for node_aProcess {
     // Creates a new process instance
     fn new(cpu_id: isize) -&gt; Self {
<span class="line-remove">-        let mut task1: taskThread = taskThread::new(cpu_id);</span>
<span class="line-remove">-        let mut task2: task2Thread = task2Thread::new(cpu_id);</span>
<span class="line-remove">-        return Self {</span>
<span class="line-remove">-            task1,</span>
<span class="line-remove">-            task2,</span>
<span class="line-remove">-            cpu_id,</span>
<span class="line-remove">-        }; //显式return;</span>
<span class="line-add">+        let task1: taskThread = taskThread::new(cpu_id);</span>
<span class="line-add">+        let task2: task2Thread = task2Thread::new(cpu_id);</span>
<span class="line-add">+        return Self { task1, task2, cpu_id }  //显式return;</span>
     }
<span class="line-remove">-</span>
<span class="line-add">+    </span>
     // Starts all threads in the process
<span class="line-remove">-    fn start(self: Self) -&gt; () {</span>
<span class="line-remove">-        let Self {</span>
<span class="line-remove">-            task1,</span>
<span class="line-remove">-            task2,</span>
<span class="line-remove">-            cpu_id,</span>
<span class="line-remove">-            ..</span>
<span class="line-remove">-        } = self;</span>
<span class="line-add">+    fn run(self: Self) -&gt; () {</span>
<span class="line-add">+        let Self { task1, task2, cpu_id, .. } = self;</span>
         thread::Builder::new()
             .name(&quot;task1&quot;.to_string())
<span class="line-remove">-            .spawn(|| task1.run())</span>
<span class="line-remove">-            .unwrap();</span>
<span class="line-add">+            .spawn(move || { task1.run() }).unwrap();</span>
         thread::Builder::new()
             .name(&quot;task2&quot;.to_string())
<span class="line-remove">-            .spawn(|| task2.run())</span>
<span class="line-remove">-            .unwrap();</span>
<span class="line-add">+            .spawn(move || { task2.run() }).unwrap();</span>
     }
<span class="line-add">+    </span>
 }

 // AADL System: rmssys
 #[derive(Debug)]
 pub struct rmssysSystem {
<span class="line-remove">-    #[allow(dead_code)]</span>
<span class="line-remove">-    pub node_a: node_aProcess, // 子组件进程（node_a : process node_a）</span>
<span class="line-add">+    pub node_a: node_aProcess,// 子组件进程（node_a : process node_a）</span>
 }

 impl System for rmssysSystem {
     // Creates a new system instance
     fn new() -&gt; Self {
<span class="line-remove">-        let mut node_a: node_aProcess = node_aProcess::new(0);</span>
<span class="line-remove">-        return Self { node_a }; //显式return;</span>
<span class="line-add">+        let mut node_a: node_aProcess = node_aProcess::new(1);</span>
<span class="line-add">+        return Self { node_a }  //显式return;</span>
     }
<span class="line-remove">-</span>
<span class="line-add">+    </span>
     // Runs the system, starts all processes
     fn run(self: Self) -&gt; () {
<span class="line-remove">-        self.node_a.start();</span>
<span class="line-add">+        self.node_a.run();</span>
     }
<span class="line-add">+    </span>
 }

 // CPU ID到调度策略的映射
<span class="line-header">@@ -242,6 +218,9 @@</span>
     static ref CPU_ID_TO_SCHED_POLICY: HashMap&lt;isize, i32&gt; = {
         let mut map: HashMap&lt;isize, i32&gt; = HashMap::new();
         map.insert(0, SCHED_FIFO);
<span class="line-add">+        map.insert(1, SCHED_FIFO);</span>
<span class="line-add">+        map.insert(2, SCHED_FIFO);</span>
<span class="line-add">+        map.insert(3, SCHED_FIFO);</span>
         return map;
     };
 }
<span class="line-header">@@ -254,3 +233,4 @@</span>
     let raw: f64 = 99.0 - k * period_ms.log10().floor();
     return raw.max(1.0).min(99.0) as i32;
 }
<span class="line-add">+</span>

</pre>
</body>
</html>
