-- This example is adapted from the ARINC653 annex document for the AADLv2

-------------------------------------------------------------------------------
-- The following example illustrates the modeling of a distributed
-- ARINC653 system with two modules. This example illustrates the
-- modeling of a communication between two ARINC653 modules with AADL.
--
-- a. In the first module, three partitions are defined. One partition
-- communicates (it sends data) ; the second does not communicate. The
-- third contains the device driver for the network interface. Since
-- the third partition contains a device driver it is considered
-- in ARINC653 to be a system partition.
--
-- b. Device drivers are specified using the Device_Driver property in
-- the textual representation. Driver internal are not represented in
-- the graphic version since there is no standardized way to represent
-- properties in the graphic notation of AADL.
--
-- c. Each partition (even system partitions that execute device
-- drivers) is bound to a part of the main memory (modeling of
-- different address spaces).
--
-- d. The second module, contains two partitions : one communicates
-- and the second contains the device driver for the network
-- interface.
--
-- e. These two ARINC653 modules communicate through AADL event data
-- ports. It maps the concept of ARINC653 queuing ports between two
-- ARINC653 modules.
--
-- f. Notice that the ARINC653 modules communicate across a bus named
-- rtbus. The association between the bus and its driver is modeled
-- with an access connection.


package arincexample2
public

  -- with ARINC653;
  -- with buses::misc;
  -- with memories;
  -- with processors;
  -- First, define generic component

  data simple_type
  properties
    Data_Model::Data_Representation => Struct;
  end simple_type;

  data implementation simple_type.impl
  subcomponents
      val : data Base_Types::Integer_32;
  end simple_type.impl;

  -- memory memchunk extends memories::ROM end memchunk;
  -- memory mainmemory extends memories::ROM end mainmemory;

  -- bus anybus extends buses::misc::generic_bus end anybus;
  -- bus implementation anybus.i extends buses::misc::generic_bus.impl end anybus.i;

  thread network_driver_thread
  end network_driver_thread;

  thread implementation network_driver_thread.i
    properties
    Stack_Size => 4 Bytes;
    Code_Size => 10 Bytes;
    Period => 200 ms;
    Compute_Execution_Time => 5 ms .. 10 ms;
    Dispatch_Protocol => Periodic;
    Priority                           => 1;
  end network_driver_thread.i;

 --  JH addition
  -- abstract network_driver_partition_holder
  -- end network_driver_partition_holder;

  -- abstract implementation network_driver_partition_holder.i
  -- subcomponents
  --   ndp : process network_driver_partition.i;
  -- end network_driver_partition_holder.i;
  -- /JH addition

  process network_driver_partition
  end network_driver_partition;

  process implementation network_driver_partition.i
  subcomponents
    thr : thread network_driver_thread.i;
  end network_driver_partition.i;

  -- device network_interface
  -- features
  --   thebus: requires bus access anybus.i;
  -- properties
  --   Device_Driver => classifier (network_driver_partition_holder.i);
  -- end network_interface;

  -- device implementation network_interface.i
  -- end network_interface.i;

  -- virtual processor partition_runtime
  -- properties
  --   Scheduling_Protocol => (POSIX_1003_HIGHEST_PRIORITY_FIRST_PROTOCOL);
  -- end partition_runtime;

  processor arinckernel -- extends processors::Generic_CPU
  end arinckernel;

  -- Then, we define the first module and its subcomponents.
  processor implementation arinckernel.module1
  -- subcomponents
  --   part1 : virtual processor partition_runtime
  --     {ARINC653::Criticality => LEVEL_A;};
  --   part2 : virtual processor partition_runtime
  --     {ARINC653::Criticality => LEVEL_B;};
  --   part3 : virtual processor partition_runtime
  --     {ARINC653::Criticality => LEVEL_C;};
  -- properties
    -- ARINC653::Module_Major_Frame => 40ms;
    -- ARINC653::Partition_Slots => (10ms, 10ms, 20ms);
    -- ARINC653::Slots_Allocation => (reference (part1), reference (part2), reference (part3));
    -- ARINC653::HM_Errors => (Power_Fail);
    -- ARINC653::HM_Module_Recovery_Actions => (Reset);
  end arinckernel.module1;

  -- memory implementation mainmemory.module1
  -- subcomponents
  --   mem1 : memory memchunk;
  --   mem2 : memory memchunk;
  --   mem3 : memory memchunk;
  -- end mainmemory.module1;

  thread module1_thread_part1
  features
    sensorout : out event data port simple_type;
  
  -- properties
  --  ARINC653::HM_Errors =>
  --          (Deadline_Miss, Application_Error, Numeric_Error, Illegal_Request);
  --  ARINC653::HM_Process_Recovery_Actions =>
  --          (Process_Restart, Process_Restart, Process_Restart, Process_Restart);
  end module1_thread_part1; -- Thread for the first partition

  thread implementation module1_thread_part1.impl
  properties
    Dispatch_Protocol => Periodic;
    Period => 100 ms;
    Priority  => 1;
  end module1_thread_part1.impl;

  thread module1_thread_part2
  -- properties
  --  ARINC653::HM_Errors =>
  --        (Deadline_Miss, Application_Error, Numeric_Error, Illegal_Request);
  --  ARINC653::HM_Process_Recovery_Actions =>
  --        (Process_Restart, Process_Restart, Process_Restart, Process_Restart);
  end module1_thread_part2; -- Thread for the second partition

  thread implementation module1_thread_part2.impl
    properties
    Dispatch_Protocol => Periodic;
    Period => 100 ms;
    Priority   => 1;
  end module1_thread_part2.impl;

  process module1_process_part1
  features
    sensorout : out event data port simple_type;
    -- {Queue_Size => 1;
    -- ARINC653::Timeout => 5ms;
    -- Queue_Processing_Protocol => FIFO;};
  properties
    Queue_Size => 1;
    -- ARINC653::Timeout => 5ms;
    -- Queue_Processing_Protocol => FIFO;
  end module1_process_part1;

  process implementation module1_process_part1.impl
  subcomponents
    mythread : thread module1_thread_part1.impl;
  connections
    Q1:port mythread.sensorout -> sensorout;
  end module1_process_part1.impl;

  -- Process for the first partition
  process module1_process_part2
  end module1_process_part2;

  process implementation module1_process_part2.impl
  subcomponents
    mythread : thread module1_thread_part2.impl;
  end module1_process_part2.impl;

  -- Process for the second partition
  -- system module1_system
  -- features
  --   -- thebus: requires bus access anybus.i;
  --   sensorout : out event data port simple_type;
  -- end module1_system;

  -- system implementation module1_system.impl
  -- subcomponents
  --   -- netif : device network_interface.i;
  --   -- mainmemory : memory mainmemory.module1;
  --   cpu : processor arinckernel.module1;
  --   process_part1 : process module1_process_part1;
  --   process_part2 : process module1_process_part2;
  -- connections
  --   Q2:port process_part1.sensorout -> sensorout;
  --   -- Q3:bus access thebus -> netif.thebus;
  -- properties
  --   -- Actual_Processor_Binding => (reference (cpu.part1)) applies to process_part1;
  --   -- Actual_Processor_Binding => (reference (cpu.part2)) applies to process_part2;
  --   -- Actual_Processor_Binding => (reference (cpu.part2)) applies to netif;

  --   -- Actual_Memory_Binding => (reference (mainmemory.mem1)) applies to process_part1;
  --   -- Actual_Memory_Binding => (reference (mainmemory.mem2)) applies to process_part2;
  --   -- Actual_Memory_Binding => (reference (mainmemory.mem3)) applies to netif;
  --   Actual_Processor_Binding => reference (cpu) applies to process_part1;
  --   Actual_Processor_Binding => reference (cpu) applies to process_part2;
  -- end module1_system.impl; -- System that contain everything for the first module -- Now, we declare the second module

  -- processor implementation arinckernel.module2
  -- -- subcomponents
  -- --   part1 : virtual processor partition_runtime;
  -- properties
  --   ARINC653::Module_Major_Frame => 40ms;
  --   -- ARINC653::Partition_Slots => (20ms, 20ms);
  --   -- ARINC653::Slots_Allocation => (reference (part1));
  --   -- ARINC653::HM_Errors => (Power_Fail);
  --   -- ARINC653::HM_Module_Recovery_Actions => (Reset);
  -- end arinckernel.module2;

  thread module2_thread_part1
  features
    sensorin : in event data port simple_type;
  -- properties
  --  ARINC653::HM_Errors =>
  --      (Deadline_Miss, Application_Error, Numeric_Error, Illegal_Request);
  --  ARINC653::HM_Process_Recovery_Actions =>
  --      (Process_Restart, Process_Restart,Process_Restart, Process_Restart);
  end module2_thread_part1;

  thread implementation module2_thread_part1.impl
    properties
    Dispatch_Protocol => Periodic;
    Period => 100 ms;
    Priority  => 1;
  end module2_thread_part1.impl;

  process module2_process_part1
  features
    sensorin : in event data port simple_type;
    -- {Queue_Size => 1;
    --  ARINC653::Timeout => 5ms;
    --  Queue_Processing_Protocol => FIFO;};
  properties
    Queue_Size => 1;
    -- ARINC653::Timeout => 5ms;
    -- Queue_Processing_Protocol => FIFO;
  end module2_process_part1;

  process implementation module2_process_part1.impl
  subcomponents
    thread_part1 : thread module2_thread_part1.impl;
  connections
    Q4:port sensorin -> thread_part1.sensorin;
  end module2_process_part1.impl;

  -- memory implementation mainmemory.module2
  -- subcomponents
  --   mem1 : memory memchunk;
  --   mem2 : memory memchunk;
  -- end mainmemory.module2;

  -- system module2_system
  -- features
  --   -- thebus	: requires bus access anybus.i;
  --   sensorin : in event data port simple_type;
  -- end module2_system;

  -- system implementation module2_system.impl
  -- subcomponents
  --   -- mainmemory	: memory mainmemory.module2;
  --   cpu	: processor arinckernel.module1;
  --   process_part1 : process module2_process_part1.impl;
  --   -- netif	: device network_interface.i;
  -- connections
  --   Q5:port sensorin -> process_part1.sensorin;
  --   -- Q6:bus access thebus -> netif.thebus;
  -- properties
  --   -- Actual_Processor_Binding	=> (reference (cpu.part1)) applies to process_part1;
  --   -- Actual_Processor_Binding	=> (reference (cpu.part1)) applies to netif;

  --   -- Actual_Memory_Binding => (reference (mainmemory.mem1)) applies to process_part1;
  --   -- Actual_Memory_Binding => (reference (mainmemory.mem2)) applies to netif;
  --   Actual_Processor_Binding	=> reference (cpu) applies to process_part1;
  -- end module2_system.impl;

  -- Now, we declare the main system that contains both modules

  system arinc653system
  end arinc653system;

  system implementation arinc653system.impl
  subcomponents
    -- module1 : system module1_system.impl;
    -- module2 : system module2_system.impl;
    -- rtbus	: bus anybus.i;
    cpu : processor arinckernel.module1;
    m1_p1 : process module1_process_part1.impl;
    m1_p2 : process module1_process_part2.impl;
    m2_p1 : process module2_process_part1.impl;
  connections
    -- conn1 : port module1.sensorout -> module2.sensorin;
    -- busaccess_module1 : bus access rtbus -> module1.thebus;
    -- busaccess_module2 : bus access rtbus -> module2.thebus;
    conn1 : port m1_p1.sensorout -> m2_p1.sensorin;
  -- properties
  --   Actual_Connection_Binding => reference (rtbus) applies to conn1;
  properties
    Actual_Processor_Binding => reference (cpu) applies to m1_p1;
    Actual_Processor_Binding => reference (cpu) applies to m1_p2;
    Actual_Processor_Binding => reference (cpu) applies to m2_p1;
  end arinc653system.impl;

end arincexample2;
